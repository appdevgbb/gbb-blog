"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[4451],{4918:e=>{e.exports=JSON.parse('{"permalink":"/2021/09/21/workload-identity-self-managed-setup","editUrl":"https://github.com/appdevgbb/gbb-blog/tree/main/docusaurus/blog/2021-09-21/workload-identity-self-managed-setup/index.md","source":"@site/blog/2021-09-21/workload-identity-self-managed-setup/index.md","title":"Using Workload Identity with Self Managed Clusters","description":"How to use Workload Identity with your own bespoke Kubernetes Cluster","date":"2021-09-21T00:00:00.000Z","tags":[],"readingTime":5.71,"hasTruncateMarker":true,"authors":[{"name":"Steve Griffith","title":"Principal Cloud Architect, Azure Global Black Belt","url":"https://github.com/swgriffith","socials":{"x":"https://x.com/SteveGriffith","github":"https://github.com/swgriffith"},"imageURL":"https://github.com/swgriffith.png","key":"steve_griffith","page":null}],"frontMatter":{"authors":["steve_griffith"],"date":"2021-09-21","description":"How to use Workload Identity with your own bespoke Kubernetes Cluster","tags":[],"title":"Using Workload Identity with Self Managed Clusters"},"unlisted":false,"prevItem":{"title":"Accessing Azure SQL DB via Workload Identity and Managed Identity","permalink":"/2021/09/21/workload-identity-azuresql-example"},"nextItem":{"title":"Workload Identity - Windows Nodepool Walkthrough","permalink":"/2021/09/21/workload-identity-windows-example"}}')},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>i});var o=n(6540);const a={},s=o.createContext(a);function r(e){const t=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),o.createElement(s.Provider,{value:t},e.children)}},8822:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var o=n(4918),a=n(4848),s=n(8453);const r={authors:["steve_griffith"],date:"2021-09-21",description:"How to use Workload Identity with your own bespoke Kubernetes Cluster",tags:[],title:"Using Workload Identity with Self Managed Clusters"},i=void 0,l={authorsImageUrls:[void 0]},c=[{value:"Cluster Creation",id:"cluster-creation",level:3},{value:"Create the Discovery Document in Blob Storage",id:"create-the-discovery-document-in-blob-storage",level:3},{value:"Create the Json Web Key Sets (jswk) file",id:"create-the-json-web-key-sets-jswk-file",level:3},{value:"Install the MutatingWebhook",id:"install-the-mutatingwebhook",level:3},{value:"Test",id:"test",level:3},{value:"Conclusion",id:"conclusion",level:2}];function u(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h3,{id:"cluster-creation",children:"Cluster Creation"}),"\n",(0,a.jsx)(t.p,{children:"For this walk through I created my cluster from scratch using kubeadm, testing on both Azure and Google Cloud. The kubeadm setup directions I followed are linked below:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://computingforgeeks.com/deploy-kubernetes-cluster-on-ubuntu-with-kubeadm/",children:"https://computingforgeeks.com/deploy-kubernetes-cluster-on-ubuntu-with-kubeadm/"})}),"\n",(0,a.jsx)(t.p,{children:"Once running you need to copy the sa.pub file from your kubernetes master node to the location where you'll be running your Azure CLI. This file is located at /etc/kubernetes/pki/sa.pub"}),"\n",(0,a.jsx)(t.h3,{id:"create-the-discovery-document-in-blob-storage",children:"Create the Discovery Document in Blob Storage"}),"\n",(0,a.jsxs)(t.p,{children:["Using the upstream document ",(0,a.jsx)(t.a,{href:"https://azure.github.io/azure-workload-identity/docs/installation/self-managed-clusters/oidc-issuer/discovery-document.html",children:"here"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'export RESOURCE_GROUP="oidcissuer"\nexport LOCATION="eastus"\n\n# Create the resource group\naz group create --name "${RESOURCE_GROUP}" --location "${LOCATION}"\n\n# Generate a unique name for the storage account\nexport AZURE_STORAGE_ACCOUNT="oidcissuer$(openssl rand -hex 4)"\nexport AZURE_STORAGE_CONTAINER="oidc-test"\n\n# Create the storage account\naz storage account create --resource-group "${RESOURCE_GROUP}" --name "${AZURE_STORAGE_ACCOUNT}"\naz storage container create --name "${AZURE_STORAGE_CONTAINER}" --public-access container\n\n# Generate the oidc well known configuration document\ncat <<EOF > openid-configuration.json\n{\n  "issuer": "https://${AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${AZURE_STORAGE_CONTAINER}/",\n  "jwks_uri": "https://${AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${AZURE_STORAGE_CONTAINER}/openid/v1/jwks",\n  "response_types_supported": [\n    "id_token"\n  ],\n  "subject_types_supported": [\n    "public"\n  ],\n  "id_token_signing_alg_values_supported": [\n    "RS256"\n  ]\n}\nEOF\n\n# Upload the well known configuration document to the blob storage account\naz storage blob upload \\\n  --container-name "${AZURE_STORAGE_CONTAINER}" \\\n  --file openid-configuration.json \\\n  --name .well-known/openid-configuration\n\n# Test the endpoint\ncurl -s "https://${AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${AZURE_STORAGE_CONTAINER}/.well-known/openid-configuration"\n'})}),"\n",(0,a.jsx)(t.h3,{id:"create-the-json-web-key-sets-jswk-file",children:"Create the Json Web Key Sets (jswk) file"}),"\n",(0,a.jsxs)(t.p,{children:["Following the guide ",(0,a.jsx)(t.a,{href:"https://azure.github.io/azure-workload-identity/docs/installation/self-managed-clusters/oidc-issuer/jwks.html",children:"here"}),", use the azwi cli to generate the jwks.json file using the sa.pub file created above. You'll need to make sure you've installed the azwi cli ",(0,a.jsx)(t.a,{href:"https://azure.github.io/azure-workload-identity/docs/installation/azwi.html",children:"here"})]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.em,{children:"Note:"})," You'll use the sa.pub file you copied from your Kuberenetes master node above."]}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'# Generate the jwks file\nazwi jwks --public-keys sa.pub --output-file jwks.json\n\n# Upload the jwks.json file to the blob account\naz storage blob upload \\\n  --container-name "${AZURE_STORAGE_CONTAINER}" \\\n  --file jwks.json \\\n  --overwrite \\\n  --name openid/v1/jwks\n\n# Test the file\ncurl -s "https://${AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${AZURE_STORAGE_CONTAINER}/openid/v1/jwks"\n'})}),"\n",(0,a.jsx)(t.p,{children:"Next you need to update the kube-apiserver configuration on your Kubernetes master node. First let's output the issuer URL."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'# Get the issuer url\necho Issuer: "https://${AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${AZURE_STORAGE_CONTAINER}/"\n\n# Sample Output\nIssuer: https://oidcissuer4e2fd2e1.blob.core.windows.net/oidc-test/\n'})}),"\n",(0,a.jsx)(t.p,{children:"Now SSH back to the master node to edit the kube-apiserver static manifest."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"# Edit the kube-apiserver manifest\nnano /etc/kubernetes/manifests/kube-apiserver.yaml \n\n# Set the service-account-issuer value to the first URL\n# The service-account settings should look like the following given the URLs above:\n\n    - --service-account-issuer=https://oidcissuer4e2fd2e1.blob.core.windows.net/oidc-test/\n    - --service-account-key-file=/etc/kubernetes/pki/sa.pub\n    - --service-account-signing-key-file=/etc/kubernetes/pki/sa.key\n\n# Save and exit.\n"})}),"\n",(0,a.jsx)(t.p,{children:"The above change will cause the API server to restart, so it may take a minute or two before the pods are back online and the API server is accessible."}),"\n",(0,a.jsx)(t.h3,{id:"install-the-mutatingwebhook",children:"Install the MutatingWebhook"}),"\n",(0,a.jsx)(t.p,{children:"Back at the terminal where you have your Azure CLI and access to the cluster via kubectl, we'll install the workload identity components."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'# Get your Azure Active Directory Tenant ID\nexport AZURE_TENANT_ID=$(az account show -o tsv --query homeTenantId)\n\n# Install the MutatingWebhook\nhelm repo add azure-workload-identity https://azure.github.io/azure-workload-identity/charts\nhelm repo update\nhelm install workload-identity-webhook azure-workload-identity/workload-identity-webhook \\\n   --namespace azure-workload-identity-system \\\n   --create-namespace \\\n   --set azureTenantID="${AZURE_TENANT_ID}"\n\n# Check the installation\nkubectl get pods -n azure-workload-identity-system\n\n# Sample Output\nNAME                                                   READY   STATUS    RESTARTS       AGE\nazure-wi-webhook-controller-manager-747c86695f-9jrk5   1/1     Running   20 (48m ago)   94m\nazure-wi-webhook-controller-manager-747c86695f-vrpkr   1/1     Running   20 (49m ago)   94m\n'})}),"\n",(0,a.jsx)(t.h3,{id:"test",children:"Test"}),"\n",(0,a.jsx)(t.p,{children:"Now the cluster is configured with all the components needed to enable service account federation and Azure Workload Identity. Lets test it out. We'll create a new service account and managed identity and federate them. We'll also create a key vault we can use to test the service account federation."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.em,{children:"Note:"})," We'll reuse the resource group variable from above, so you may need to reset it if you have a new terminal session."]}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"# Set the managed identity and oidc issuer variables\nMANAGED_IDENTITY_NAME=testmi\nOIDC_ISSUER=<Get the oidc issuer url from above>\n\n# Create the managed identity\naz identity create --name $MANAGED_IDENTITY_NAME --resource-group $RESOURCE_GROUP\n\n# Get the client ID\nexport USER_ASSIGNED_CLIENT_ID=$(az identity show --resource-group $RESOURCE_GROUP --name $MANAGED_IDENTITY_NAME --query 'clientId' -o tsv)\n\n# Create the namespace and service account\nNAMESPACE=wi-test\n\nkubectl create ns $NAMESPACE\n\ncat <<EOF | kubectl apply -f -\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  annotations:\n    azure.workload.identity/client-id: ${USER_ASSIGNED_CLIENT_ID}\n  labels:\n    azure.workload.identity/use: \"true\"\n  name: ${MANAGED_IDENTITY_NAME}-sa\n  namespace: ${NAMESPACE}\nEOF\n\n# Federate the service account and managed identity\naz identity federated-credential create \\\n--name $MANAGED_IDENTITY_NAME-federated-id \\\n--identity-name $MANAGED_IDENTITY_NAME \\\n--resource-group $RESOURCE_GROUP \\\n--issuer ${OIDC_ISSUER} \\\n--subject system:serviceaccount:$NAMESPACE:$MANAGED_IDENTITY_NAME-sa\n"})}),"\n",(0,a.jsx)(t.p,{children:"For testing purposes we'll create a key vault and a secret which is authorized for read access by the managed identity we created above."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'KEY_VAULT_NAME=vault$(openssl rand -hex 4)\n\n# Create a key vault\naz keyvault create --name $KEY_VAULT_NAME --resource-group $RESOURCE_GROUP\n\n# Create a secret\naz keyvault secret set --vault-name $KEY_VAULT_NAME --name "Secret" --value "Hello from key vault"\n\n# Grant access to the secret for the managed identity using it\'s AAD client ID\naz keyvault set-policy --name $KEY_VAULT_NAME --secret-permissions get --spn "${USER_ASSIGNED_CLIENT_ID}"\n\n'})}),"\n",(0,a.jsxs)(t.p,{children:["For the test app we'll use a Key Vault test container I created previously. You can see the code ",(0,a.jsx)(t.a,{href:"https://github.com/Azure/reddog-aks-workshop/blob/main/docs/cheatsheets/workload-identity-cheatsheet.md#write-the-code-to-test-your-workload-identity-setup",children:"here"})]}),"\n",(0,a.jsx)(t.p,{children:"Deploy the test app:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"# Deploy the app\ncat <<EOF | kubectl apply -f -\napiVersion: v1\nkind: Pod\nmetadata:\n  name: wi-kv-test\n  namespace: ${NAMESPACE}\nspec:\n  serviceAccountName: ${MANAGED_IDENTITY_NAME}-sa\n  containers:\n    - image: stevegriffith/wi-kv-test\n      name: wi-kv-test\n      env:\n      - name: KEY_VAULT_NAME\n        value: ${KEY_VAULT_NAME}\n      - name: SECRET_NAME\n        value: Secret    \n  nodeSelector:\n    kubernetes.io/os: linux\nEOF\n\n# Check the pod is running\nkubectl get pods -n $NAMESPACE\n\n# Sample Output\nNAME         READY   STATUS    RESTARTS   AGE\nwi-kv-test   1/1     Running   0          19s\n\n# Check the pod logs to confirm it's connecting to key vault with the authorized managed identity\nkubectl logs -f wi-kv-test -n $NAMESPACE\n\n# Sample output\nRetrieving your secret from vault70abc350.\nYour secret is 'Hello from key vault'.\nRetrieving your secret from vault70abc350.\nYour secret is 'Hello from key vault'.\nRetrieving your secret from vault70abc350.\nYour secret is 'Hello from key vault'.\nRetrieving your secret from vault70abc350.\nYour secret is 'Hello from key vault'.\n"})}),"\n",(0,a.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(t.p,{children:"You should now have a working setup of Azure Workload Identity in your self managed cluster, connecting to keyvault to retrieve a secret via an authorized managed identity which has been federated to a kubernetes service account used by the application pod."})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}}}]);