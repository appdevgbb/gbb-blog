"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[150],{585:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/addendpoint3-c06fd89920842350cdc44dc39ab7ebaf.jpg"},1515:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/addendpoint1-8a7657fa4dee42db284d4b38c7003bfd.jpg"},1614:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var r=n(3156),a=n(4848),i=n(8453);const s={authors:["steve_griffith"],date:"2024-11-05",description:"Using Azure Front Door in-front of an in-cluster nginx ingress controller to provide end-to-end TLS encryption of application traffic.",tags:[],title:"End to End TLS Encryption with AKS and AFD"},o="End to End TLS Encryption with AKS and AFD",l={authorsImageUrls:[void 0]},c=[{value:"Introduction",id:"introduction",level:2},{value:"Network Setup",id:"network-setup",level:2},{value:"Cluster Creation",id:"cluster-creation",level:2},{value:"Setup Workload Identity",id:"setup-workload-identity",level:2},{value:"Create the Azure Key Vault and Upload Certificate",id:"create-the-azure-key-vault-and-upload-certificate",level:2},{value:"Option 1: App Service Certificates",id:"option-1-app-service-certificates",level:3},{value:"Option 2: LetsEncrypt/CertBot",id:"option-2-letsencryptcertbot",level:3},{value:"Set up the Key Vault CSI Secret Provider Class",id:"set-up-the-key-vault-csi-secret-provider-class",level:2},{value:"Deploy the Ingress Controller",id:"deploy-the-ingress-controller",level:2},{value:"Deploy a Sample App",id:"deploy-a-sample-app",level:2},{value:"Create the Azure Front Door",id:"create-the-azure-front-door",level:2},{value:"Link the certificate to the AFD.",id:"link-the-certificate-to-the-afd",level:3},{value:"Create the Custom Domain Configuration",id:"create-the-custom-domain-configuration",level:3},{value:"Create the Origin Group",id:"create-the-origin-group",level:3},{value:"Create the AFD Endpoint",id:"create-the-afd-endpoint",level:3},{value:"Update your DNS",id:"update-your-dns",level:3},{value:"Approve the Private Link request",id:"approve-the-private-link-request",level:3},{value:"Test",id:"test",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(t.p,{children:"In this walkthrough we'll create deploy an app with end to end TLS encryption, using Azure Front Door as the Internet Facing TLS endpoint and an Nginx Ingress controller running inside an AKS cluster as the backend."}),"\n",(0,a.jsx)(t.p,{children:"We'll use Azure Key Vault to store the TLS certificate, and will use the Key Vault CSI Driver to get the secrets into the ingress controller. The Key Vault CSI Driver will use Azure Workload Identity to safely retrieve the certificate."}),"\n",(0,a.jsx)(t.p,{children:"Let's get to it...."}),"\n",(0,a.jsx)(t.h2,{id:"network-setup",children:"Network Setup"}),"\n",(0,a.jsx)(t.p,{children:"First, we'll need to establish the network where our AKS cluster will be deployed. Nothing special in our network design, other than the fact that I'm creating an Azure Network Security Group at the subnet level for added security."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"# Resource Group Creation\nRG=E2ETLSLab\nLOC=eastus2\n\n# Create the Resource Group\naz group create -g $RG -l $LOC\n\n# Get the resource group id\nRG_ID=$(az group show -g $RG -o tsv --query id)\n\n# Set an environment variable for the VNet name\nVNET_NAME=lablab-vnet\nVNET_ADDRESS_SPACE=10.140.0.0/16\nAKS_SUBNET_ADDRESS_SPACE=10.140.0.0/24\n\n# Create an NSG at the subnet level for security reasons\naz network nsg create \\\n--resource-group $RG \\\n--name aks-subnet-nsg\n\n# Get the NSG ID\nNSG_ID=$(az network nsg show -g $RG -n aks-subnet-nsg -o tsv --query id)\n\n# Create the Vnet along with the initial subet for AKS\naz network vnet create \\\n-g $RG \\\n-n $VNET_NAME \\\n--address-prefix $VNET_ADDRESS_SPACE \\\n--subnet-name aks \\\n--subnet-prefix $AKS_SUBNET_ADDRESS_SPACE \\\n--network-security-group aks-subnet-nsg\n\n# Get a subnet resource ID, which we'll need when we create the AKS cluster\nVNET_SUBNET_ID=$(az network vnet subnet show -g $RG --vnet-name $VNET_NAME -n aks -o tsv --query id)\n"})}),"\n",(0,a.jsx)(t.h2,{id:"cluster-creation",children:"Cluster Creation"}),"\n",(0,a.jsx)(t.p,{children:"Now, lets create the AKS cluster where our workload and ingress controller will reside. This will be a very plain AKS cluster, however we will deploy to our above created subnet and will enable the following features:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.em,{children:"Workload Identity:"})," This will be used by the Key Vault CSI Driver to retrieve the cluster certificate"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.em,{children:"OIDC Issuer:"})," This is required by Workload Identity to be used during service account fedration"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.em,{children:"Key Vault CSI Driver:"})," This will be used to retrieve the cluster certificate"]}),"\n"]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.em,{children:"Note:"})," Since I created a NSG at the subnet level, I'll need to create a custom role which will be used later for automated private link creation. If you don't have an NSG on the subnet, and just rely on the managed NSG that AKS owns, then you don't need to create the custom role documented below."]}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'# NOTE: Make sure you give your cluster a unique name\nCLUSTER_NAME=e2etlslab\n\n# Cluster Creation Command\naz aks create \\\n-g $RG \\\n-n $CLUSTER_NAME \\\n--node-count 2 \\\n--enable-oidc-issuer \\\n--enable-workload-identity \\\n--enable-addons azure-keyvault-secrets-provider \\\n--vnet-subnet-id $VNET_SUBNET_ID\n\n# Get the cluster identity\nCLUSTER_IDENTITY=$(az aks show -g $RG -n $CLUSTER_NAME -o tsv --query identity.principalId)\n\n###################################################################################################\n# Grant the cluster identity rights on the cluster nsg, which we\'ll need later when we create the\n# private link.\n\n# NOTE: These steps are only needed if you have a custom NSG on the cluster subnet.\n\n# Create the role definition file\ncat << EOF > pl-nsg-role.json\n{\n    "Name": "Private Link AKS Role",\n    "Description": "Grants the cluster rights on the NSG for Private Link Creation",\n    "Actions": [\n        "Microsoft.Network/networkSecurityGroups/join/action"\n    ],\n    "NotActions": [],\n    "DataActions": [],\n    "NotDataActions": [],\n    "assignableScopes": [\n        "${RG_ID}"\n    ]\n}\nEOF\n\n# Create the role definition in Azure\naz role definition create --role-definition @pl-nsg-role.json\n\n# Assign the role\n# NOTE: New role propegation may take a minute or to, so retry as needed\naz role assignment create \\\n--role "Private Link AKS Role" \\\n--assignee $CLUSTER_IDENTITY \\\n--scope $NSG_ID\n###################################################################################################\n\n\n# Get credentials\naz aks get-credentials -g $RG -n $CLUSTER_NAME\n'})}),"\n",(0,a.jsx)(t.h2,{id:"setup-workload-identity",children:"Setup Workload Identity"}),"\n",(0,a.jsx)(t.p,{children:"Now that we have our cluster, lets finish setting up the workload identity that will be used to retrieve our certificate from Azure Key Vault."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.em,{children:"Note:"})," For simplicity, I'm keeping all resources in the 'default' namespace. You may want to modify this for your own deployment."]}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'# Set the namespace where we will deploy our app and ingress controller\nNAMESPACE=default\n\n# Get the OIDC Issuer URL\nexport AKS_OIDC_ISSUER="$(az aks show -n $CLUSTER_NAME -g $RG --query "oidcIssuerProfile.issuerUrl" -otsv)"\n\n# Get the Tenant ID for later\nexport IDENTITY_TENANT=$(az account show -o tsv --query tenantId)\n\n# Create the managed identity\naz identity create --name nginx-ingress-identity --resource-group $RG --location $LOC\n\n# Get identity client ID\nexport USER_ASSIGNED_CLIENT_ID=$(az identity show --resource-group $RG --name nginx-ingress-identity --query \'clientId\' -o tsv)\n\n# Create a service account to federate with the managed identity\ncat <<EOF | kubectl apply -f -\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  annotations:\n    azure.workload.identity/client-id: ${USER_ASSIGNED_CLIENT_ID}\n  labels:\n    azure.workload.identity/use: "true"\n  name: nginx-ingress-sa\n  namespace: ${NAMESPACE}\nEOF\n\n# Federate the identity\naz identity federated-credential create \\\n--name nginx-ingress-federated-id \\\n--identity-name nginx-ingress-identity \\\n--resource-group $RG \\\n--issuer ${AKS_OIDC_ISSUER} \\\n--subject system:serviceaccount:${NAMESPACE}:nginx-ingress-sa\n'})}),"\n",(0,a.jsx)(t.h2,{id:"create-the-azure-key-vault-and-upload-certificate",children:"Create the Azure Key Vault and Upload Certificate"}),"\n",(0,a.jsx)(t.p,{children:"Now, lets create our Azure Key Vault and then create and upload our certificate."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'# Create a key vault name\nKEY_VAULT_NAME=e2elab$RANDOM\n\n# Create the key vaule\naz keyvault create --name $KEY_VAULT_NAME --resource-group $RG --location $LOC --enable-rbac-authorization false\n\n# Grant access to the secret for the managed identity\naz keyvault set-policy --name $KEY_VAULT_NAME -g $RG --certificate-permissions get --spn "${USER_ASSIGNED_CLIENT_ID}"\naz keyvault set-policy --name $KEY_VAULT_NAME -g $RG --secret-permissions get --spn "${USER_ASSIGNED_CLIENT_ID}"\n'})}),"\n",(0,a.jsx)(t.p,{children:"For certificate creation, I actually took two separate paths."}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.em,{children:"Option 1:"})," Use Azure ",(0,a.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/azure/app-service/configure-ssl-app-service-certificate?tabs=portal",children:"App Service Certificates"})," to create and manage the certificate."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.em,{children:"Option 2:"})," Use '",(0,a.jsx)(t.a,{href:"https://letsencrypt.org/",children:"LetsEncrypt"}),"' and ",(0,a.jsx)(t.a,{href:"https://certbot.eff.org/",children:"Certbot"})," to create the certificate."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Both options are totally fine, but have slight differences in approach, which I'll highlight below. If you're working in a large enterprise, you'll likely have a completely separate internal process for getting a certificate. In the end, all we care about is that we have a valid cert and key file."}),"\n",(0,a.jsx)(t.h3,{id:"option-1-app-service-certificates",children:"Option 1: App Service Certificates"}),"\n",(0,a.jsxs)(t.p,{children:["We won't cover all the details of setting up a certificate with App Service Certificates, but you can review the doc ",(0,a.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/azure/app-service/configure-ssl-app-service-certificate?tabs=portal",children:"here"})," for those steps."]}),"\n",(0,a.jsxs)(t.p,{children:["When I created the certificate, I told App Svc Certs to store the cert in the Key Vault just created. We'll use the ",(0,a.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/azure/aks/csi-secrets-store-driver",children:"Key Vault CSI Driver"})," to mount the certificate into the ingress controller, but to do that we need to get the certficate into a format that the CSI driver can read. App Svc Certs stores the certificate in an Azure Key Vault in pfx format as a secret, but for the Key Vault CSI Driver we need it stored as a certificate. We can export the PFX from the Azure Key Vault Secret and then import it as a certificate."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'APP_CERT_NAME=e2elab\n\n# Get the secret name for the certificate in key vault\nSECRET_NAME=$(az resource show --resource-group $RG --resource-type "Microsoft.CertificateRegistration/certificateOrders" --name $APP_CERT_NAME --query "properties.certificates.$APP_CERT_NAME.keyVaultSecretName" --output tsv)\n\n# Download the certificate \naz keyvault secret download --file $APP_CERT_NAME.pfx --vault-name $KEY_VAULT_NAME --name $SECRET_NAME --encoding base64\n\n# Import the certificate\naz keyvault certificate import --vault-name $KEY_VAULT_NAME --name $APP_CERT_NAME --file $APP_CERT_NAME.pfx\n'})}),"\n",(0,a.jsx)(t.h3,{id:"option-2-letsencryptcertbot",children:"Option 2: LetsEncrypt/CertBot"}),"\n",(0,a.jsx)(t.p,{children:"I'm not going to get into all the specifics of using Certbot with LetsEncrypt, but the basic are as follows. The domain I'll be using is my 'crashoverride.nyc' domain."}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"Get an internet reachable host capable of running a webserver on ports 80 and 443"}),"\n",(0,a.jsx)(t.li,{children:"Create an A-record for your target domain to the public IP of the server. This is required for hostname validation used by Certbot"}),"\n",(0,a.jsx)(t.li,{children:"Run the certbot command as a priviledged user on that web server host mentioned in #1 above"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Here's a sample of the command I used to create a cert with two entries in the certificate Subject Alternate Names:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"sudo certbot certonly --key-type rsa --standalone -d e2elab.crashoverride.nyc -d www.crashoverride.nyc\n"})}),"\n",(0,a.jsx)(t.p,{children:"Certbot creates several files, all with the PEM file extension. This is misleading, as fullchain.pem is the 'crt' file and the privkey.pem is the 'key' file. To store these in Azure Key Vault as certs we'll need to package these files up in a PFX format."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"APP_CERT_NAME=crashoverride\n\n# export to pfx\n# skipping the Password prompt\nopenssl pkcs12 -export -passout pass: -in fullchain.pem -inkey privkey.pem  -out ${APP_CERT_NAME}.pfx\n\n# Import the certificate\naz keyvault certificate import --vault-name $KEY_VAULT_NAME --name $APP_CERT_NAME --file $APP_CERT_NAME.pfx\n"})}),"\n",(0,a.jsx)(t.h2,{id:"set-up-the-key-vault-csi-secret-provider-class",children:"Set up the Key Vault CSI Secret Provider Class"}),"\n",(0,a.jsx)(t.p,{children:"Great! Now we have our network, cluster, key vault and secrets ready to go. We can now create our SecretProviderClass, which is the link between our Kubernetes resources and the secret in Azure Key Vault. We'll actually use this SecretProviderClass to mount the certificate into our ingress controller."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.em,{children:"Note:"})," The Key Vault CSI driver uses the Kubernetes Container Storage Interface to initiate it's connection to Key Vault. That means, even though we really only care about having the certificate as a Kubernetes secret for use in our ingress definition, we still need to mount the secret as a volume to create the Kubernetes Secret. We'll mount the certificate secret to the ingress controller, but you could mount it to your app alternatively, especially if you plan to use the certificate in your app directly as well."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"When you create a certificate in Azure Key Vault and then use the Key Vault CSI driver to access that certificate, you use the 'secret' object type and the certificate name. The returned secret contains the certificate key and crt file using the names tls.key and tls.crt."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'# We\'ll cat the SecretProviderClass direclty into kubectl\n# You could also just cat it out to a file and use that file to deploy\ncat << EOF | kubectl apply -f -\napiVersion: secrets-store.csi.x-k8s.io/v1\nkind: SecretProviderClass\nmetadata:\n  name: crashoverride-tls\n  namespace: ${NAMESPACE}\nspec:\n  provider: azure\n  secretObjects:                            # secretObjects defines the desired state of synced K8s secret objects\n    - secretName: crashoverride-tls-csi\n      type: kubernetes.io/tls\n      data: \n        - objectName: crashoverride\n          key: crashoverride.key\n        - objectName: crashoverride\n          key: crashoverride.crt\n  parameters:\n    usePodIdentity: "false"\n    clientID: ${USER_ASSIGNED_CLIENT_ID}\n    keyvaultName: ${KEY_VAULT_NAME}                 # the name of the AKV instance\n    objects: |\n      array:\n        - |\n          objectName: crashoverride\n          objectType: secret\n    tenantId: ${IDENTITY_TENANT}                    # the tenant ID of the AKV instance\nEOF\n'})}),"\n",(0,a.jsx)(t.h2,{id:"deploy-the-ingress-controller",children:"Deploy the Ingress Controller"}),"\n",(0,a.jsx)(t.p,{children:"Now we're ready to create our ingress controller. For our purposes, and for it's simplicity, we're going to use ingress-nginx. The approach will be roughly the same for any ingress controller."}),"\n",(0,a.jsx)(t.p,{children:"There are a few key points to note in the deployment below."}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"We want our ingress controller to be on an internal network with no public IP, since Azure Front Door will provide the public endpoint. To do that we'll need to apply the 'azure-load-balancer-internal' annotation."}),"\n",(0,a.jsx)(t.li,{children:"Azure Front Door can only connect to a private IP address using an Azure Private Link Service. Fortunately, AKS provides the 'azure-pls-create' annotation which will automatically create and manage a private link for you."}),"\n",(0,a.jsx)(t.li,{children:"As mentioned above, since we're using the Key Vault CSI Driver, we need to mount the Secret Provider Class using the secret-store driver."}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx\nhelm repo update\n\n# Generate the values file we\'ll use to deploy ingress-nginx\ncat <<EOF > nginx-ingress-values.yaml\nserviceAccount:\n  create: false\n  name: nginx-ingress-sa\ncontroller:\n  replicaCount: 2\n  service:\n    annotations:\n      service.beta.kubernetes.io/azure-load-balancer-health-probe-request-path: /healthz\n      service.beta.kubernetes.io/azure-load-balancer-internal: "true"\n      service.beta.kubernetes.io/azure-pls-create: "true"\n  extraVolumes:\n      - name: crashoverride-secret-store\n        csi:\n          driver: secrets-store.csi.k8s.io\n          readOnly: true\n          volumeAttributes:\n            secretProviderClass: "crashoverride-tls"            \n  extraVolumeMounts:\n      - name: crashoverride-secret-store\n        mountPath: "/mnt/crashoverride"\n        readOnly: true        \nEOF\n\n# Deploy ingress-nginx\nhelm install e2elab-ic ingress-nginx/ingress-nginx \\\n    --namespace $NAMESPACE \\\n    -f nginx-ingress-values.yaml\n'})}),"\n",(0,a.jsx)(t.h2,{id:"deploy-a-sample-app",children:"Deploy a Sample App"}),"\n",(0,a.jsxs)(t.p,{children:["We'll need a sample app to test our configuration. I personally like the '",(0,a.jsx)(t.a,{href:"https://github.com/cilium/echoserver",children:"echoserver"}),"' app from the cilium team. It's nice, as it returns the HTTP headers as the web response, which can be very useful in http request testing."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"cat <<EOF | kubectl apply -f -\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: aks-helloworld \nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: aks-helloworld\n  template:\n    metadata:\n      labels:\n        app: aks-helloworld\n    spec:\n      containers:\n      - name: aks-helloworld\n        image: cilium/echoserver\n        ports:\n        - containerPort: 8080\n        env:\n        - name: PORT\n          value: '8080'\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: aks-helloworld\nspec:\n  type: ClusterIP\n  ports:\n  - port: 8080\n  selector:\n    app: aks-helloworld\nEOF\n"})}),"\n",(0,a.jsx)(t.p,{children:"Now we can deploy the ingress defintion. Look out for the following:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"The 'tls' section maps the inbound TLS request to the appropriate certificate secret"}),"\n",(0,a.jsx)(t.li,{children:"The 'rules' section maps the target host name to the backend service that should be targetted"}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'cat <<EOF|kubectl apply -f -\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: crashoverride-ingress-tls\n  annotations:\n    nginx.ingress.kubernetes.io/use-regex: "true"\n    nginx.ingress.kubernetes.io/rewrite-target: /$1\nspec:\n  ingressClassName: nginx\n  tls:\n  - hosts:\n    - e2elab.crashoverride.nyc\n    secretName: crashoverride-tls-csi \n  rules:\n  - host: e2elab.crashoverride.nyc\n    http:\n      paths:\n      - path: /hello-world\n        pathType: Prefix\n        backend:\n          service:\n            name: aks-helloworld\n            port:\n              number: 8080\nEOF\n'})}),"\n",(0,a.jsx)(t.p,{children:"Since we haven't set up the Azure Front Door yet, we cant access the app on the public IP yet. We can fake this out, however, with some curl magic. curl lets you call a local endpoint and pretend like you're connecting to a different host name. We'll need this for our ingress certificate to work."}),"\n",(0,a.jsx)(t.p,{children:"First we port-forward and then we'll curl with some special options."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.em,{children:"Note:"})," If you prefer, you can also just edit your local 'hosts' file to fake out the DNS lookup. Just create an entry that maps your local loopback address (127.0.0.1) to your DNS name."]}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"# In terminal 1, port-forward to the ingress nginx service name\nkubectl port-forward svc/e2elab-ic-ingress-nginx-controller 8443:443\n\n# In terminal 2 run a curl like the following, changing out for your host name\ncurl -v https://e2elab.crashoverride.nyc/hello-world --connect-to e2elab.crashoverride.nyc:443:127.0.0.1:8443\n"})}),"\n",(0,a.jsx)(t.p,{children:"You should have seen a successful TLS handshake with your certificate and proper hostname."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'# Example\n* Server certificate:\n*  subject: CN=e2elab.crashoverride.nyc\n*  start date: Oct 31 16:35:44 2024 GMT\n*  expire date: Jan 29 16:35:43 2025 GMT\n*  subjectAltName: host "e2elab.crashoverride.nyc" matched cert\'s "e2elab.crashoverride.nyc"\n*  issuer: C=US; O=Let\'s Encrypt; CN=R10\n*  SSL certificate verify ok.\n'})}),"\n",(0,a.jsx)(t.h2,{id:"create-the-azure-front-door",children:"Create the Azure Front Door"}),"\n",(0,a.jsx)(t.p,{children:"Now that the backend is working, lets wire up the Azure Front Door."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"# Create the Azure Front Door\naz afd profile create \\\n--profile-name e2elab \\\n--resource-group $RG \\\n--sku Premium_AzureFrontDoor\n"})}),"\n",(0,a.jsxs)(t.p,{children:["We'll do the rest in the Azure Portal, so open a browser to ",(0,a.jsx)(t.a,{href:"https://portal.azure.com",children:"https://portal.azure.com"}),"."]}),"\n",(0,a.jsx)(t.h3,{id:"link-the-certificate-to-the-afd",children:"Link the certificate to the AFD."}),"\n",(0,a.jsx)(t.p,{children:"To use our certificate with Azure Front Door, we need to attach the certificate in Azure Key Vault to an Front Door Secret. We do this in the 'Secrets' pane under 'Security'."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"link certificate",src:n(3910).A+"",width:"1514",height:"820"})}),"\n",(0,a.jsx)(t.h3,{id:"create-the-custom-domain-configuration",children:"Create the Custom Domain Configuration"}),"\n",(0,a.jsx)(t.p,{children:"Now we tell AFD what domain we'd like to use and link that domain name to the associated secret that we just created for our certificate."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"afd add domain 1",src:n(5206).A+"",width:"826",height:"499"})}),"\n",(0,a.jsx)(t.p,{children:"Next we select the appropriate secret for our domain."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"afd add domain 2",src:n(6625).A+"",width:"1240",height:"826"})}),"\n",(0,a.jsx)(t.p,{children:"Finally, we see the domain entry created and pending association with an endpoint."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"afd add domain 3",src:n(9252).A+"",width:"1517",height:"324"})}),"\n",(0,a.jsx)(t.h3,{id:"create-the-origin-group",children:"Create the Origin Group"}),"\n",(0,a.jsx)(t.p,{children:"Front Door is acting as the entry point to our backend, which is referred to as the 'Origin'."}),"\n",(0,a.jsx)(t.p,{children:"Creating the origin group is a two step process. You create the origin group, but as part of that you also add the origin hostname configuration. As part of that origin hostname setup you will check the 'Enable Private Link Service' option, which will allow you to select the private link that was automatically created by AKS for your ingress-nginx deployment. This is why the service annotation was so important when you deployed ingress-nginx."}),"\n",(0,a.jsx)(t.p,{children:"You'll provide a message that will show up on the private link approval side. This message can be whatever you want."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"origin setup 1",src:n(5525).A+"",width:"1542",height:"1054"})}),"\n",(0,a.jsx)(t.p,{children:"Now we complete our origin setup, making sure to set the right path to our ingress health probe. In our case, the URL will forward to '/hello-world', as we know this will return an HTTP 200 response. If you have your own health endpoint, you can set that here."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"origin setup 2",src:n(8298).A+"",width:"1552",height:"1045"})}),"\n",(0,a.jsx)(t.p,{children:"Now we see that our origin is created, but still pending association with an endpoint."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"origin setup 3",src:n(6583).A+"",width:"1561",height:"502"})}),"\n",(0,a.jsx)(t.h3,{id:"create-the-afd-endpoint",children:"Create the AFD Endpoint"}),"\n",(0,a.jsx)(t.p,{children:"In 'Front Door manager' select 'Add an endpoint' and give the endpoint a name. Make note of the FQDN is provides. This will be used in our DNS for the CNAME."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"add an endpoint 1",src:n(1515).A+"",width:"1094",height:"554"})}),"\n",(0,a.jsx)(t.p,{children:"Now we'll add a route by clicking 'Add a route'."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"add an endpoint 2",src:n(7151).A+"",width:"1472",height:"571"})}),"\n",(0,a.jsx)(t.p,{children:"In the 'add route' screen, we'll select our origin and the associated domain, and set any additional options. At this point, you should also make note of the endpoint FQDN, which we'll need to use as our CNAME in our DNS for our host name."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"add an endpoint 3",src:n(585).A+"",width:"929",height:"1157"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"add an endpoint 4",src:n(9690).A+"",width:"862",height:"270"})}),"\n",(0,a.jsx)(t.p,{children:"When finished, your endpoint should look as follows."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"add an endpoint 5",src:n(5527).A+"",width:"1142",height:"429"})}),"\n",(0,a.jsx)(t.h3,{id:"update-your-dns",children:"Update your DNS"}),"\n",(0,a.jsx)(t.p,{children:"We need our DNS name to point to the Azure Front Door endpoint, so we'll take that Front Door provided FQDN and create a CNAME record."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"dns cname entry",src:n(1709).A+"",width:"1156",height:"108"})}),"\n",(0,a.jsx)(t.h3,{id:"approve-the-private-link-request",children:"Approve the Private Link request"}),"\n",(0,a.jsx)(t.p,{children:"Ok, so we associated the Azure Front Door origin with our private link, but we never approved the private link association request. To do that, we'll need to go to the AKS managed cluster (MC_) resource group. Lets get that resource group name and then go approve the request."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"# Get the managed cluster resource group name\nAKS_CLUSTER_MC_RG=$(az aks show -g $RG -n $CLUSTER_NAME -o tsv --query nodeResourceGroup)\n"})}),"\n",(0,a.jsx)(t.p,{children:"Back in the Azure Portal, navigate to the Managed Cluster Resource Group and find the private link."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"approve private link 1",src:n(3468).A+"",width:"1597",height:"783"})}),"\n",(0,a.jsx)(t.p,{children:"Click on the 'Private endpoint connections' where you should see a pending request."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"approve private link 2",src:n(9915).A+"",width:"1500",height:"445"})}),"\n",(0,a.jsx)(t.p,{children:"Select the private link and click 'Approve'."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"approve private link 3",src:n(9758).A+"",width:"663",height:"201"})}),"\n",(0,a.jsx)(t.p,{children:"You'll see a dialog box with the message you sent when creating the origin connection."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"approve private link 4",src:n(8997).A+"",width:"773",height:"224"})}),"\n",(0,a.jsx)(t.h2,{id:"test",children:"Test"}),"\n",(0,a.jsx)(t.p,{children:"You should now be able to open a browser and navigate to your URL. You can also test with curl."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"curl https://e2elab.crashoverride.nyc/hello-world\n\n##########################################\n# Sample Output\n##########################################\nHostname: aks-helloworld-fbdf59bf-qtdks\n\nPod Information:\n\t-no pod information available-\n\nServer values:\n\tserver_version=nginx: 1.13.3 - lua: 10008\n\nRequest Information:\n\tclient_address=\n\tmethod=GET\n\treal path=/\n\tquery=\n\trequest_version=1.1\n\trequest_scheme=http\n\trequest_uri=http://e2elab.crashoverride.nyc:8080/\n\nRequest Headers:\n\taccept=*/*\n\thost=e2elab.crashoverride.nyc\n\tuser-agent=curl/8.7.1\n\tvia=HTTP/2.0 Azure\n\tx-azure-clientip=70.18.42.220\n\tx-azure-fdid=c7e0d3e0-830a-4770-acae-14d27c7726f8\n\tx-azure-ref=\n\tx-azure-requestchainv2=hops=2\n\tx-azure-socketip=\n\tx-forwarded-for=10.140.0.5\n\tx-forwarded-host=e2elab.crashoverride.nyc\n\tx-forwarded-port=443\n\tx-forwarded-proto=https\n\tx-forwarded-scheme=https\n\tx-original-forwarded-for=\n\tx-real-ip=10.140.0.5\n\tx-request-id=8f41e792d8f0f74e90ddca9d14ba896b\n\tx-scheme=https\n\nRequest Body:\n\t-no body in request-\n"})}),"\n",(0,a.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(t.p,{children:"Congrats! You should now have a working Azure Front Door directing TLS secured traffic to an in cluster ingress controller!"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.em,{children:"Note:"})," In this walk through we did not add encryption between the ingress controller and the backend deployment. This can be done by sharing the same, or different, certificate to the deployment pods. You then enable backend encryption on the ingress controller. Alternatively, you could use a service mesh between the ingress and the backend deployment."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},1709:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/dnscname-8fbedb12cb53f94762424bf996a3d132.jpg"},3156:e=>{e.exports=JSON.parse('{"permalink":"/2024/11/05/afd-aks-ingress-tls","editUrl":"https://github.com/appdevgbb/gbb-blog/tree/main/docusaurus/blog/2024-11-05/afd-aks-ingress-tls/index.md","source":"@site/blog/2024-11-05/afd-aks-ingress-tls/index.md","title":"End to End TLS Encryption with AKS and AFD","description":"Using Azure Front Door in-front of an in-cluster nginx ingress controller to provide end-to-end TLS encryption of application traffic.","date":"2024-11-05T00:00:00.000Z","tags":[],"readingTime":17.05,"hasTruncateMarker":true,"authors":[{"name":"Steve Griffith","title":"Principal Cloud Architect, Azure Global Black Belt","url":"https://github.com/swgriffith","socials":{"x":"https://x.com/SteveGriffith","github":"https://github.com/swgriffith"},"imageURL":"https://github.com/swgriffith.png","key":"steve_griffith","page":null}],"frontMatter":{"authors":["steve_griffith"],"date":"2024-11-05","description":"Using Azure Front Door in-front of an in-cluster nginx ingress controller to provide end-to-end TLS encryption of application traffic.","tags":[],"title":"End to End TLS Encryption with AKS and AFD"},"unlisted":false,"prevItem":{"title":"Updating AKS Network Plugin from Kubenet to Azure CNI","permalink":"/2025/01/31/updating-aks-network-plugin-from-kubenet-to-azure-cni"},"nextItem":{"title":"Multi-Cluster Layer 4 Load Balancing with Fleet Manager","permalink":"/2024/09/06/multi-cluster-layer-4-load-balancing-with-fleet-manager"}}')},3468:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/approvepl1-87e675028c6844a6ca14ba78885ab29e.jpg"},3910:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/linkcert-aefeafab109f97330d25e8bdb2a7f4da.jpg"},5206:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/afd-adddomain1-d2c537a5bdcdeb7f3e901d1bf50d8da2.jpg"},5525:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/origin-setup1-ccba7b8a83371b1b42ea8395b4d40173.jpg"},5527:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/addendpoint5-89e54f6811a19af215df9063f4d68702.jpg"},6583:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/origin-setup3-b13fef5f35c4a4a367f3b6d2f6d179a0.jpg"},6625:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/afd-adddomain2-b9ed436d9cc4feddaefa36690b784893.jpg"},7151:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/addendpoint2-99a313ff2cd2b776d3c1dc23157ee62f.jpg"},8298:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/origin-setup2-2f7dcaf794d0a289b31aca9b72ee361b.jpg"},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var r=n(6540);const a={},i=r.createContext(a);function s(e){const t=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:t},e.children)}},8997:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/approvepl4-61865f245d88072ea396e0da64fc1d21.jpg"},9252:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/afd-adddomain3-0a8251c81e3a5d6d33d6dd87d4016bcc.jpg"},9690:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/addendpoint4-f8ddd53f17f80fc96dea5563f8a8022c.jpg"},9758:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/approvepl3-70628f6d17487ce753fcacaade5dd549.jpg"},9915:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/approvepl2-c958b49e159cb530586c4ae8847aaaf7.jpg"}}]);