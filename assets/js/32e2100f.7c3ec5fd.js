"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[1844],{651:e=>{e.exports=JSON.parse('{"permalink":"/2024/03/05/workload-identity-kv-csi","editUrl":"https://github.com/appdevgbb/gbb-blog/tree/main/docusaurus/blog/2024-03-05/workload-identity-kv-csi/index.md","source":"@site/blog/2024-03-05/workload-identity-kv-csi/index.md","title":"Using the Azure Key Vault CSI Driver with Workload Identity","description":"Setting up an AKS cluster with Workload Identity and the Key Vault CSI driver and using them from a SecretProviderClass and Pod to load secrets.","date":"2024-03-05T00:00:00.000Z","tags":[],"readingTime":6.8,"hasTruncateMarker":true,"authors":[{"name":"Steve Griffith","title":"Principal Cloud Architect, Azure Global Black Belt","url":"https://github.com/swgriffith","socials":{"x":"https://x.com/SteveGriffith","github":"https://github.com/swgriffith"},"imageURL":"https://github.com/swgriffith.png","key":"steve_griffith","page":null}],"frontMatter":{"authors":["steve_griffith"],"date":"2024-03-05","description":"Setting up an AKS cluster with Workload Identity and the Key Vault CSI driver and using them from a SecretProviderClass and Pod to load secrets.","tags":[],"title":"Using the Azure Key Vault CSI Driver with Workload Identity"},"unlisted":false,"prevItem":{"title":"Using Project KAITO in AKS","permalink":"/2024/04/16/aks-kaito"},"nextItem":{"title":"Securing your AKS cluster with a Linux Firewall VM","permalink":"/2024/02/02/securing-your-aks-cluster-with-a-linux-firewall-vm"}}')},6940:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var r=n(651),s=n(4848),a=n(8453);const o={authors:["steve_griffith"],date:"2024-03-05",description:"Setting up an AKS cluster with Workload Identity and the Key Vault CSI driver and using them from a SecretProviderClass and Pod to load secrets.",tags:[],title:"Using the Azure Key Vault CSI Driver with Workload Identity"},i="Workload Identity - Key Vault CSI Driver",c={authorsImageUrls:[void 0]},d=[{value:"Cluster Creation",id:"cluster-creation",level:3},{value:"Set up the identity",id:"set-up-the-identity",level:3},{value:"Create the Key Vault and Secret",id:"create-the-key-vault-and-secret",level:3},{value:"Sync the same secret to a Kubernetes Secret",id:"sync-the-same-secret-to-a-kubernetes-secret",level:3},{value:"Conclusion",id:"conclusion",level:3}];function l(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h3:"h3",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"When working with secrets in an application running in Kubernetes, you can use native Kubernetes secrets, however there are limitations in the security of those secrets. A better practice is to use a secure vault, like Azure Key Vault."}),"\n",(0,s.jsxs)(t.p,{children:["Azure Key Vault can be accessed via a direct SDK call, as demonstrated in our previous ",(0,s.jsx)(t.a,{href:"https://azureglobalblackbelts.com/2023/09/21/workload-identity-example.html",children:"Workload Identity"})," post. However, in some cases you may not have the option to use the SDK, like in cases where you dont have access to source code. In those cases you may prefer to load secrets directly into an environment variable or a file. In these cases, the Azure Key Vault CSI driver is here to save the day."]}),"\n",(0,s.jsxs)(t.p,{children:["The following walkthrough shows how you can using ",(0,s.jsx)(t.a,{href:"https://azure.github.io/azure-workload-identity/docs/",children:"Azure Workload Identity"})," with the ",(0,s.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/azure/aks/workload-identity-overview",children:"AKS Workload Identity"})," add-on along with the Key Vault CSI Driver to mount secrets and volumes in your pods."]}),"\n",(0,s.jsx)(t.h3,{id:"cluster-creation",children:"Cluster Creation"}),"\n",(0,s.jsx)(t.p,{children:"First, lets create the AKS cluster with the OIDC Issuer, Workload Identity and the Key Vault CSI Driver add-ons enabled."}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"NOTE:"})," Both the OIDC Issuer and Workload Identity add-ons are needed if you want to use workload identities, however the Key Vault CSI driver can also work with service principals or even the managed identity assigned to the cluster itself. Using Workload Identity, however, is the most versatile and secure approach."]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"RG=WorkloadIdentityKVCSIRG\nLOC=eastus\nCLUSTER_NAME=wikvcsilab\nUNIQUE_ID=$CLUSTER_NAME$RANDOM\nKEY_VAULT_NAME=$UNIQUE_ID\n\n# Create the resource group\naz group create -g $RG -l $LOC\n\n# Create the cluster with the OIDC Issuer and Workload Identity enabled\naz aks create -g $RG -n $CLUSTER_NAME \\\n--node-count 1 \\\n--enable-oidc-issuer \\\n--enable-workload-identity \\\n--enable-addons azure-keyvault-secrets-provider \\\n--generate-ssh-keys\n\n# Get the cluster credentials\naz aks get-credentials -g $RG -n $CLUSTER_NAME\n"})}),"\n",(0,s.jsx)(t.h3,{id:"set-up-the-identity",children:"Set up the identity"}),"\n",(0,s.jsx)(t.p,{children:"In order to federate a managed identity with a Kubernetes Service Account we need to get the AKS OIDC Issure URL, create the Managed Identity and Service Account and then create the federation."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:'# Get the OIDC Issuer URL\nexport AKS_OIDC_ISSUER="$(az aks show -n $CLUSTER_NAME -g $RG --query "oidcIssuerProfile.issuerUrl" -otsv)"\n\n# Get the Tenant ID for later\nexport IDENTITY_TENANT=$(az account show -o tsv --query tenantId)\n\n# Create the managed identity\naz identity create --name kvcsi-demo-identity --resource-group $RG --location $LOC\n\n# Get identity client ID\nexport USER_ASSIGNED_CLIENT_ID=$(az identity show --resource-group $RG --name kvcsi-demo-identity --query \'clientId\' -o tsv)\n\n# Create a service account to federate with the managed identity\ncat <<EOF | kubectl apply -f -\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  annotations:\n    azure.workload.identity/client-id: ${USER_ASSIGNED_CLIENT_ID}\n  labels:\n    azure.workload.identity/use: "true"\n  name: kvcsi-demo-sa\n  namespace: default\nEOF\n\n# Federate the identity\naz identity federated-credential create \\\n--name kvcsi-demo-federated-id \\\n--identity-name kvcsi-demo-identity \\\n--resource-group $RG \\\n--issuer ${AKS_OIDC_ISSUER} \\\n--subject system:serviceaccount:default:kvcsi-demo-sa\n'})}),"\n",(0,s.jsx)(t.h3,{id:"create-the-key-vault-and-secret",children:"Create the Key Vault and Secret"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:'# Create a key vault\naz keyvault create --name $KEY_VAULT_NAME --resource-group $RG --location $LOC --enable-rbac-authorization false\n\n# Create a secret\naz keyvault secret set --vault-name $KEY_VAULT_NAME --name "TestSecret" --value "Hello from Key Vault"\n\n# Grant access to the secret for the managed identity\naz keyvault set-policy --name $KEY_VAULT_NAME -g $RG --secret-permissions get --spn "${USER_ASSIGNED_CLIENT_ID}"\n\n#####################################################################\n# OPTIONAL\n# We\'ll get the version ID for the secret but this is not mandatory\n#####################################################################\n\n# Get the version ID\naz keyvault secret show --vault-name $KEY_VAULT_NAME --name "TestSecret" -o tsv --query id\nhttps://wi-demo-keyvault.vault.azure.net/secrets/Secret/ded8e5e3b3e040e9bfa5c47d0e28848a\n\n# The version ID is the last part of the resource id above\n# We\'ll use this later\nVERSION_ID=ded8e5e3b3e040e9bfa5c47d0e28848a\n'})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"https://secrets-store-csi-driver.sigs.k8s.io/getting-started/usage",children:"SecretProviderClass"})," is what is used to create the binding between the Kubernetes cluster and the Azure Key Vault. It allows you to define the identity accessing the Key Vault, the target Key Vault name and the details about the keys and secrets being accessed. It will also let you link Key Vault Secrets to Kubernetes Secrets, but we'll see more on that later."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:'# Create a secret provider instance attached to the vault and secret\ncat <<EOF | kubectl apply -f -\napiVersion: secrets-store.csi.x-k8s.io/v1\nkind: SecretProviderClass\nmetadata:\n  name: azure-kvcsi-wi # needs to be unique per namespace\nspec:\n  provider: azure\n  parameters:\n    usePodIdentity: "false"\n    clientID: "${USER_ASSIGNED_CLIENT_ID}" # Setting this to use workload identity\n    keyvaultName: ${KEY_VAULT_NAME}       # Set to the name of your key vault\n    cloudName: ""                         # [OPTIONAL for Azure] if not provided, the Azure environment defaults to AzurePublicCloud\n    objects:  |\n      array:\n        - |\n          objectName: TestSecret             # Set to the name of your secret\n          objectType: secret              # object types: secret, key, or cert\n          objectVersion: "${VERSION_ID}"               # [OPTIONAL] object versions, default to latest if empty\n    tenantId: "${IDENTITY_TENANT}"        # The tenant ID of the key vault\nEOF\n'})}),"\n",(0,s.jsx)(t.p,{children:"Now deploy a pod that gets the value using the service account identity."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:'# Create a pod to mount the secret\ncat <<EOF | kubectl apply -f -\nkind: Pod\napiVersion: v1\nmetadata:\n  name: secrets-store-inline-wi\n  labels:\n    azure.workload.identity/use: "true"\nspec:\n  serviceAccountName: "kvcsi-demo-sa"\n  containers:\n    - name: ubuntu\n      image: ubuntu:20.04\n      command: [ "/bin/bash", "-c", "--" ]\n      args: [ "while true; do sleep 30; done;" ]\n      volumeMounts:\n      - name: secrets-store01-inline\n        mountPath: "/mnt/secrets-store"\n        readOnly: true\n  volumes:\n    - name: secrets-store01-inline\n      csi:\n        driver: secrets-store.csi.k8s.io\n        readOnly: true\n        volumeAttributes:\n          secretProviderClass: "azure-kvcsi-wi"\nEOF\n\n# Check the secret loaded\nkubectl exec -it secrets-store-inline-wi -- cat /mnt/secrets-store/TestSecret\n'})}),"\n",(0,s.jsx)(t.h3,{id:"sync-the-same-secret-to-a-kubernetes-secret",children:"Sync the same secret to a Kubernetes Secret"}),"\n",(0,s.jsx)(t.p,{children:"As mentioned above, you do have the option to synchronize Azure Key Vault secrets to Kubernetes secrets, which can be very useful. Just keep in mind that this driver uses the Container Storage Interface (CSI) so you still need to ensure a pod mounts a volume associated to the SecretProviderClass to initiate the Kubernetes secret creation."}),"\n",(0,s.jsx)(t.p,{children:"Lets add a new SecretProviderClass that includes the secret synchronization configuration."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:'# Create a secret provider instance attached to the vault and secret\ncat <<EOF | kubectl apply -f -\napiVersion: secrets-store.csi.x-k8s.io/v1\nkind: SecretProviderClass\nmetadata:\n  name: azure-kvcsi-wi-sync # needs to be unique per namespace\nspec:\n  provider: azure\n  parameters:\n    usePodIdentity: "false"\n    clientID: "${USER_ASSIGNED_CLIENT_ID}" # Setting this to use workload identity\n    keyvaultName: ${KEY_VAULT_NAME}       # Set to the name of your key vault\n    cloudName: ""                         # [OPTIONAL for Azure] if not provided, the Azure environment defaults to AzurePublicCloud\n    objects:  |\n      array:\n        - |\n          objectName: TestSecret             # Set to the name of your secret\n          objectType: secret              # object types: secret, key, or cert\n          objectVersion: "${VERSION_ID}"               # [OPTIONAL] object versions, default to latest if empty\n    tenantId: "${IDENTITY_TENANT}"        # The tenant ID of the key vault\n  secretObjects:                              # [OPTIONAL] SecretObjects defines the desired state of synced Kubernetes secret objects\n  - data:\n    - key: secretvalue                           # data field to populate\n      objectName: TestSecret                        # name of the mounted content to sync; this could be the object name or the object alias\n    secretName: foosecret                     # name of the Kubernetes secret object\n    type: Opaque     \nEOF\n'})}),"\n",(0,s.jsx)(t.p,{children:"Now, create a pod that loads the secret both as a volume and an environment variable from our synchronized Kubernetes secret."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:'# Create a pod to mount the secret\ncat <<EOF | kubectl apply -f -\nkind: Pod\napiVersion: v1\nmetadata:\n  name: secrets-store-inline-wi-sync\n  labels:\n    azure.workload.identity/use: "true"\nspec:\n  serviceAccountName: "kvcsi-demo-sa"\n  containers:\n    - name: ubuntu\n      image: ubuntu:20.04\n      command: [ "/bin/bash", "-c", "--" ]\n      args: [ "while true; do sleep 30; done;" ]\n      volumeMounts:\n      - name: secrets-store01-inline\n        mountPath: "/mnt/secrets-store"\n        readOnly: true\n      env:\n      - name: SECRET_DATA\n        valueFrom:\n          secretKeyRef:\n            name: foosecret\n            key: secretvalue        \n  volumes:\n    - name: secrets-store01-inline\n      csi:\n        driver: secrets-store.csi.k8s.io\n        readOnly: true\n        volumeAttributes:\n          secretProviderClass: "azure-kvcsi-wi-sync"\nEOF\n'})}),"\n",(0,s.jsx)(t.p,{children:"Finally, test to make sure the secret is properly loaded to the volume and environment variable."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"# Check that the secret was properly mounted as a volume\nkubectl exec -it secrets-store-inline-wi-sync -- cat /mnt/secrets-store/TestSecret\n\n# Check that the Kubernetes Secret was created\nkubectl get secret foosecret -o jsonpath='{.data.secretvalue}'|base64 --decode\n\n# Check that the secret was properly mounted from the kubernetes secret as an enviornment variable\nkubectl exec -it secrets-store-inline-wi-sync -- /bin/bash -c 'echo $SECRET_DATA'\n"})}),"\n",(0,s.jsx)(t.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(t.p,{children:"Congrats! You should now have a working pod that mounts a key vault secret via the CSI driver and another pod that mounts the secret as an environment variable from a sync'd Kubernetes Secret."})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var r=n(6540);const s={},a=r.createContext(s);function o(e){const t=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);