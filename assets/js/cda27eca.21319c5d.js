"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[8891],{2409:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var o=n(3340),r=n(4848),a=n(8453);const i={authors:["steve_griffith"],date:"2024-04-16",description:"Setting up an AKS cluster with the Kubernetes AI Toolchain Operator (KAITO) managed add-on and then deploying an inference model from your own private Azure Containter Registry.",tags:[],title:"Using Project KAITO in AKS"},s="Project KAITO and the AKS Managed Add-on",l={authorsImageUrls:[void 0]},u=[{value:"Cluster Creation",id:"cluster-creation",level:2},{value:"Setup the KAITO Identity",id:"setup-the-kaito-identity",level:2},{value:"Set up the Azure Container Registry",id:"set-up-the-azure-container-registry",level:2},{value:"Deploy a model!",id:"deploy-a-model",level:2},{value:"Test your inference endpoint",id:"test-your-inference-endpoint",level:2},{value:"Conclustion",id:"conclustion",level:2}];function c(e){const t={a:"a",blockquote:"blockquote",code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"The Kubernetes AI Toolchain Operator, also known as Project KAITO, is an open-source solution to simplify the deployment of inference models in a Kubernetes cluster. In particular, the focus is on simplifying the operation of the most popular models available (ex. Falcon, Mistral and Llama2)."}),"\n",(0,r.jsx)(t.p,{children:"KAITO provides operators to manage validation of the requested model against the requested nodepool hardware, deployment of the nodepool and the deployment of the model itself along with a REST endpoint to reach the model."}),"\n",(0,r.jsxs)(t.p,{children:["In this walkthrough we'll deploy an AKS cluster with the KAITO managed add-on. Next, we'll deploy and test an inference  model, which we'll pull from our own private container registry. We'll be following the setup guide from the AKS product docs ",(0,r.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/azure/aks/ai-toolchain-operator",children:"here"})," with some of my own customizations and extensions to simplify tasks."]}),"\n",(0,r.jsx)(t.h2,{id:"cluster-creation",children:"Cluster Creation"}),"\n",(0,r.jsxs)(t.p,{children:["In this setup we'll be creating a very basic AKS cluster via the ",(0,r.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/cli/azure/",children:"Azure CLI"}),", but this managed add-on will work in any AKS cluster, assuming you meet the ",(0,r.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/azure/aks/ai-toolchain-operator#prerequisites",children:"pre-reqs"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"We'll also be creating an Azure Container Registry to demonstrate replicating a KAITO model to your own private registry and using it in the model deployment, which would be a security best practice."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"# Set Variables\nRG=KaitoLab\nLOC=westus3\nACR_NAME=kaitolab\nCLUSTER_NAME=kaito\n\n# Create the resource group\naz group create -n $RG -l $LOC\n\n# Create the Azure Container Registry\naz acr create -g $RG -n $ACR_NAME --sku Standard\n\n# Create the AKS Cluster\naz aks create \\\n-g $RG \\\n-n $CLUSTER_NAME \\\n--enable-oidc-issuer \\\n--enable-ai-toolchain-operator\n\n# Get the Cluster Credentials\naz aks get-credentials -g $RG -n $CLUSTER_NAME\n"})}),"\n",(0,r.jsx)(t.h2,{id:"setup-the-kaito-identity",children:"Setup the KAITO Identity"}),"\n",(0,r.jsx)(t.p,{children:"KAITO uses the node auto-provisioner to add nodepools to the AKS cluster. To do this it needs rights on the cluster resource group. At this time the rights are broad, but as KAITO reaches general availabiliy we should see those roles refined."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:'# Get the Cluster Resource Group\nexport RG_ID=$(az group show -n $RG -o tsv --query id)\n\n# Get the managed cluster Resource Group\nexport MC_RESOURCE_GROUP=$(az aks show --resource-group ${RG} --name ${CLUSTER_NAME} --query nodeResourceGroup -o tsv)\n\n# Set a variable for the KAITO IDentity name\nexport KAITO_IDENTITY_NAME="ai-toolchain-operator-${CLUSTER_NAME}"\n\n# Get the principal ID for the KAITO managed identity\nexport PRINCIPAL_ID=$(az identity show --name "${KAITO_IDENTITY_NAME}" --resource-group "${MC_RESOURCE_GROUP}" --query \'principalId\' -o tsv)\n\n# Grant contributor on the cluster resource group\naz role assignment create --role "Contributor" --assignee "${PRINCIPAL_ID}" --scope $RG_ID\n\n# Get the OIDC Issuer URL\nexport AKS_OIDC_ISSUER=$(az aks show --resource-group "${RG}" --name "${CLUSTER_NAME}" --query "oidcIssuerProfile.issuerUrl" -o tsv)\n\n# Create the federation between the KAITO service account and the KAITO Azure Managed Identity\naz identity federated-credential create --name "kaito-federated-identity" --identity-name "${KAITO_IDENTITY_NAME}" -g "${MC_RESOURCE_GROUP}" --issuer "${AKS_OIDC_ISSUER}" --subject system:serviceaccount:"kube-system:kaito-gpu-provisioner" --audience api://AzureADTokenExchange\n\n# If you check the kaito-gpu-provisioner pod, you\'ll see it\'s in CrashLoopBackOff\n# due to the identity not yet having been configured with proper rights.\nkubectl get pods -l app=ai-toolchain-operator -n kube-system\n\n# Restart the GPU provisioner to reload authorization\nkubectl rollout restart deployment/kaito-gpu-provisioner -n kube-system\n\n# Check the pod again to confirm it\'s now running\nkubectl get pods -l app=ai-toolchain-operator -n kube-system\n'})}),"\n",(0,r.jsx)(t.h2,{id:"set-up-the-azure-container-registry",children:"Set up the Azure Container Registry"}),"\n",(0,r.jsx)(t.p,{children:"The KAITO team builds and hosts the most popular inference models for you. These models are available in the Microsoft Container Registry (MCR) and if you run a KAITO workspace for one of those models it will pull that image for you automatically. However, as noted above, security best practice is to only pull images from your own trusted repository. Fortunately, KAITO gives you this option."}),"\n",(0,r.jsx)(t.p,{children:"Let's pull the image from the MCR into our Azure Container Registry, and link that registry to our AKS cluster. The image for the model in the MCR follows a standard format, as seen below. We just need the model name and version and we can import it into our private registry. We'll use Mistral-7B."}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"NOTE:"})," If you aren't already aware, Large Language Models are LARGE. This import will take some time. Assume 10-20 minutes for many models."]}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:'MODELNAME=mistral-7b-instruct\nTAG="0.0.2"\n\n# Copy over the mistral image to our ACR\naz acr import -g $RG --name $ACR_NAME --source  mcr.microsoft.com/aks/kaito/kaito-$MODELNAME:$TAG --image $MODELNAME:$TAG\n'})}),"\n",(0,r.jsx)(t.p,{children:"While the import is running, we can go ahead and start another terminal window to attach the Azure Container Registry to our AKS cluster."}),"\n",(0,r.jsx)(t.p,{children:"We don't need to attach the ACR, if we prefer to use admin credentials and an image pull secret, but using the attach feature is more secure as it authenticates to ACR with the kubelet managed identity."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"# If we're in a new terminal window we'll need to set our environment variables\nRG=KaitoLab\nCLUSTER_NAME=kaitocluster\nACR_NAME=kaitolab\n\n# Attach the ACR\naz aks update -g $RG -n $CLUSTER_NAME --attach-acr $ACR_NAME\n"})}),"\n",(0,r.jsx)(t.h2,{id:"deploy-a-model",children:"Deploy a model!"}),"\n",(0,r.jsxs)(t.p,{children:["Now that our cluster and registry are all set, we're ready to deploy our first model. We'll generate our 'Workspace' manifest ourselves, but you can also pull from the ",(0,r.jsx)(t.a,{href:"https://github.com/Azure/kaito/blob/main/presets/README.md",children:"examples"})," in the KAITO repo and update as needed. The model below is actually directly from the examples; however I added the 'presetOptions' section to set the source of the model image."]}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"NOTE:"})," Make sure you validate you have quota on the target subscription for the machine type you select below."]}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:'# Set the target machine size\nMACHINE_SIZE=Standard_NC64as_T4_v3\n\n# Generate the model manifest\ncat <<EOF >${MODELNAME}-${TAG}.yaml\napiVersion: kaito.sh/v1alpha1\nkind: Workspace\nmetadata:\n  name: workspace-${MODELNAME}\nresource:\n  instanceType: "${MACHINE_SIZE}"\n  labelSelector:\n    matchLabels:\n      apps: ${MODELNAME}\ninference:\n  preset:\n    name: "${MODELNAME}"\n    presetOptions:\n      image: ${ACR_NAME}.azurecr.io/${MODELNAME}:${TAG}\nEOF\n\n# OPTIONAL: In another terminal, if you wish, watch the gpu and workspace provisioner logs\nkubectl logs -f -l app=ai-toolchain-operator -n kube-system\n\n# Deploy Mistral\nkubectl apply -f ${MODELNAME}-${TAG}.yaml\n\n# Watch the deployment \n# This will take some time as the node provisions and the model is pulled\nwatch kubectl get workspace,nodes,svc,pods\n'})}),"\n",(0,r.jsx)(t.h2,{id:"test-your-inference-endpoint",children:"Test your inference endpoint"}),"\n",(0,r.jsx)(t.p,{children:"Now that our model is running, we can send it a request. By default, the model is only accessible via a ClusterIP inside the Kubernetes cluster, so you'll need to access the endpoint from a test pod. We'll use a public 'curl' image, but you can use whatever you prefer."}),"\n",(0,r.jsx)(t.p,{children:"You do have the option to expose the model via a Kubernetes Service of type 'LoadBalancer' via the workspace configuration, but that generally isn't recommended. Typically, you'd be calling the model from another service inside the cluster, or placing the endpoint behind an ingress controller."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:'# Get the model cluster IP\nCLUSTERIP=$(kubectl get svc workspace-${MODELNAME} -o jsonpath=\'{.spec.clusterIP}\')\n\n# Curl the model service\nkubectl run -it --rm --restart=Never curl --image=curlimages/curl -- \\\ncurl -X POST http://$CLUSTERIP/chat \\\n-H "accept: application/json" \\\n-H "Content-Type: application/json" \\\n-d "{\\"prompt\\":\\"Who is Inigo Montoya and from what movie?\\",\\"generate_kwargs\\":{\\"max_length\\":200}}"\n'})}),"\n",(0,r.jsx)(t.h2,{id:"conclustion",children:"Conclustion"}),"\n",(0,r.jsxs)(t.p,{children:["Congratulations! You should now have a working AKS cluster with the Kubernetes AI Toolchain Operator up and running. As you explore KAITO please feel free to reach out to the KAITO team via the ",(0,r.jsx)(t.a,{href:"https://github.com/Azure/kaito/issues",children:"open-source project"})," for any questions or feature requests."]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},3340:e=>{e.exports=JSON.parse('{"permalink":"/2024/04/16/aks-kaito","editUrl":"https://github.com/appdevgbb/gbb-blog/tree/main/docusaurus/blog/2024-04-16/aks-kaito/index.md","source":"@site/blog/2024-04-16/aks-kaito/index.md","title":"Using Project KAITO in AKS","description":"Setting up an AKS cluster with the Kubernetes AI Toolchain Operator (KAITO) managed add-on and then deploying an inference model from your own private Azure Containter Registry.","date":"2024-04-16T00:00:00.000Z","tags":[],"readingTime":6.2,"hasTruncateMarker":true,"authors":[{"name":"Steve Griffith","title":"Principal Cloud Architect, Azure Global Black Belt","url":"https://github.com/swgriffith","socials":{"x":"https://x.com/SteveGriffith","github":"https://github.com/swgriffith"},"imageURL":"https://github.com/swgriffith.png","key":"steve_griffith","page":null}],"frontMatter":{"authors":["steve_griffith"],"date":"2024-04-16","description":"Setting up an AKS cluster with the Kubernetes AI Toolchain Operator (KAITO) managed add-on and then deploying an inference model from your own private Azure Containter Registry.","tags":[],"title":"Using Project KAITO in AKS"},"unlisted":false,"prevItem":{"title":"Using Stream Analytics to Filter AKS Control Plane Logs","permalink":"/2024/08/15/aks-control-plane-log-filtering"},"nextItem":{"title":"Using the Azure Key Vault CSI Driver with Workload Identity","permalink":"/2024/03/05/workload-identity-kv-csi"}}')},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>s});var o=n(6540);const r={},a=o.createContext(r);function i(e){const t=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);