"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[2567],{1850:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>r,toc:()=>c});var r=n(4372),a=n(4848),i=n(8453);const l={authors:["diego_casati"],date:"2024-02-02",description:"How to configure the firewall VM, the virtual network, and the network security group to route traffic to your AKS endpoints.",tags:[],title:"Securing your AKS cluster with a Linux Firewall VM"},o="Securing your AKS cluster with a Linux Firewall VM",s={authorsImageUrls:[void 0]},c=[{value:"Scenario 1: NVA routing to a pod through an internal load balancer",id:"scenario-1-nva-routing-to-a-pod-through-an-internal-load-balancer",level:3},{value:"Create a sample workload",id:"create-a-sample-workload",level:4},{value:"Create an internal load balancer",id:"create-an-internal-load-balancer",level:4},{value:"Setup the firewall",id:"setup-the-firewall",level:4},{value:"Scenario 2: NVA routing directly to a pod",id:"scenario-2-nva-routing-directly-to-a-pod",level:3},{value:"Testing and validating",id:"testing-and-validating",level:4},{value:"Conclusion",id:"conclusion",level:3}];function h(e){const t={a:"a",code:"code",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"A network virtual appliance (NVA) is a virtual machine that performs network functions such as firewalling. In this post, I will walk you through how to use a Linux VM as an NVA in Azure and route traffic to an endpoint running on Azure Kubernetes Service (AKS). I will cover two scenarios: one where the traffic goes through an internal load balancer, and another where the traffic goes directly to a pod."}),"\n",(0,a.jsxs)(t.p,{children:["This assumes you already have a Linux VM and an AKS Cluster created - both in their own VNET. The cluster and the Linux VM need to be VNET peered already. ",(0,a.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/azure/virtual-network/virtual-network-manage-peering?tabs=peering-cli",children:"Here is a quick start on VNET peering if you need a refresher"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["For this example we will be using Ubuntu 22.04. Since we have a few excellent tutorials on how to create a Linux VM on Azure I will not be describing that process here. If you need an example, ",(0,a.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/azure/virtual-machines/linux/tutorial-manage-vm",children:"here's a good one that describe the creation process using the Azure CLI"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["After your VM is created, ",(0,a.jsx)(t.code,{children:"ssh"})," into it and allow IP forwarding:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"sysctl -w net.ipv4.ip_forward=1\n"})}),"\n",(0,a.jsxs)(t.p,{children:["For that change to be persistent, make sure you add it to ",(0,a.jsx)(t.code,{children:"/etc/sysctl.conf"}),". Moving on, let's look into our first scenario."]}),"\n",(0,a.jsx)(t.h3,{id:"scenario-1-nva-routing-to-a-pod-through-an-internal-load-balancer",children:"Scenario 1: NVA routing to a pod through an internal load balancer"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"scenario 1",src:n(7781).A+"",width:"1021",height:"564"})}),"\n",(0,a.jsx)(t.p,{children:"In this scenario, we will route traffic from the Linux VM to a pod in the AKS cluster through an internal load balancer. The internal load balancer will balance the traffic among the pods that match a certain label selector. The diagram below shows the network topology for this scenario:"}),"\n",(0,a.jsx)(t.p,{children:"To implement this scenario, we will need to do the following steps:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Create a sample workload on the AKS cluster"}),"\n",(0,a.jsx)(t.li,{children:"Create an internal load balancer on the AKS cluster"}),"\n",(0,a.jsx)(t.li,{children:"Set up the firewall rules on the Linux VM"}),"\n"]}),"\n",(0,a.jsx)(t.h4,{id:"create-a-sample-workload",children:"Create a sample workload"}),"\n",(0,a.jsxs)(t.p,{children:["First, we will create a sample workload on the AKS cluster to test our traffic routing. We will use a simple Python web server that listens on port 80 and returns a hello message. We will deploy a pod that runs this web server and label it with ",(0,a.jsx)(t.code,{children:"run: tmp-shell"}),". To do this, run the following commands:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"# Connect to the AKS cluster\naz aks get-credentials --resource-group <your-resource-group> --name <your-aks-cluster>\n\n# Deploy a pod for testing\nkubectl run tmp-shell --image nicolaka/netshoot --labels run=tmp-shell\n\n# Run a simple Python web server on port 80\nkubectl exec -it tmp-shell -- python3 -m http.server 80\n"})}),"\n",(0,a.jsx)(t.p,{children:"You should see something like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...\n"})}),"\n",(0,a.jsx)(t.h4,{id:"create-an-internal-load-balancer",children:"Create an internal load balancer"}),"\n",(0,a.jsxs)(t.p,{children:["Next, we will create an internal load balancer on the AKS cluster that will expose the pod on port ",(0,a.jsx)(t.code,{children:"49180"}),". The internal load balancer will use the label selector ",(0,a.jsx)(t.code,{children:"run: tmp-shell"})," to find the pod and balance the traffic among the pods that match this selector. To do this, run the following commands:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'# Create a service of type LoadBalancer with an annotation to make it internal\ncat <<EOF | kubectl apply -f -\napiVersion: v1\nkind: Service\nmetadata:\n  name: tmp-shell\n  annotations:\n    service.beta.kubernetes.io/azure-load-balancer-internal: "true"\nspec:\n  type: LoadBalancer\n  ports:\n  - port: 49180\n  selector:\n    run: tmp-shell\nEOF\n'})}),"\n",(0,a.jsxs)(t.p,{children:["This will create a service named tmp-shell of type LoadBalancer with an annotation to make it internal. The service will expose port 49180 and forward the traffic to port 80 of the pod that matches the label selector ",(0,a.jsx)(t.code,{children:"run: tmp-shell"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"To verify that the service is created and has an internal IP address, run the following command:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"kubectl get service tmp-shell\n"})}),"\n",(0,a.jsx)(t.p,{children:"You should see something like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"NAME         TYPE           CLUSTER-IP     EXTERNAL-IP    PORT(S)           AGE\nkubernetes   ClusterIP      10.0.0.1       <none>         443/TCP           2d1h\ntmp-shell    LoadBalancer   10.0.166.113   10.224.0.222   49180:30265/TCP   47h\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This means that the service has an internal IP address of ",(0,a.jsx)(t.code,{children:"10.224.0.222"})," and is listening on port 49180."]}),"\n",(0,a.jsx)(t.h4,{id:"setup-the-firewall",children:"Setup the firewall"}),"\n",(0,a.jsx)(t.p,{children:"Finally, we will set up the firewall rules on the Linux VM to route the traffic from the VM to the internal load balancer. We will use iptables to configure the firewall rules. To do this, run the following commands on the Linux VM:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"iptables -A FORWARD -p tcp --syn --dport 49181 -m conntrack --ctstate NEW -j ACCEPT\niptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\niptables -P FORWARD DROP\niptables -t nat -A PREROUTING -i eth0 -p tcp --dport 49181 -j DNAT --to-destination 10.224.0.222\niptables -t nat -A POSTROUTING -o eth0 -p tcp --dport 49181 -d 10.224.0.222 -j SNAT --to-source 10.3.0.4\n"})}),"\n",(0,a.jsx)(t.p,{children:"Explanation:"}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Rule"}),(0,a.jsx)(t.th,{children:"Notes"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"iptables -A PREROUTING -i eth0 -p tcp -m tcp --dport 49181 -j DNAT --to-destination 10.224.0.222"}),(0,a.jsx)(t.td,{children:"Packet arrived on eth0 (coming from the public IP of the VM) and get's DNAT'ed to the Internal Load Balancer private IP and to the service in AKS that will send traffic to the pod on port 80."})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"iptables -A FORWARD -p tcp -m tcp --dport 49181 -m conntrack --ctstate NEW -j ACCEPT"}),(0,a.jsx)(t.td,{children:"Allow forwarding on port 49181."})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT"}),(0,a.jsx)(t.td,{children:"Match any packet that is related to an existing connection, using the conntrack module. This is necessary to allow the established and related connections to the internal service."})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"iptables -P FORWARD DROP"}),(0,a.jsx)(t.td,{children:"Set the policy to drop packets in the FORWARD chain. This means, unless specified (see line above) we will drop traffic."})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"iptables -A POSTROUTING -d 10.224.0.222/32 -o eth0 -p tcp -m tcp --dport 49181 -j SNAT --to-source 10.3.0.4"}),(0,a.jsx)(t.td,{children:"Send traffic to the Internal Load Balancer on port 49181. SNAT the source IP with the private IP of the firewall (10.3.0.4)."})]})]})]}),"\n",(0,a.jsxs)(t.p,{children:["At this point in time, our rules are in place but they will not persist a reboot. To make sure the Firewall loads these rules on boot time we need to install the ",(0,a.jsx)(t.code,{children:"iptables-persistent"})," package:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"$ sudo apt install iptables-persistent\n"})}),"\n",(0,a.jsx)(t.p,{children:"Once that's installed, save your current configuration so iptables-persistent can load them during boot time:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"$ sudo iptables-save > /etc/iptables/rules.v4\n"})}),"\n",(0,a.jsx)(t.h3,{id:"scenario-2-nva-routing-directly-to-a-pod",children:"Scenario 2: NVA routing directly to a pod"}),"\n",(0,a.jsx)(t.p,{children:"In this second scenario, we will route traffic from the Linux VM directly to a pod in the AKS cluster without going through an internal load balancer. The diagram below shows the network topology for this scenario:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"scenario 2",src:n(5178).A+"",width:"965",height:"533"})}),"\n",(0,a.jsx)(t.p,{children:"To implement this scenario, we will need to do the following steps:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Create a sample workload on the AKS cluster. Follow the steps described earlier to the deploy the POD using ",(0,a.jsx)(t.code,{children:"netshoot"})," as your base image. You do not need to deploy the Internal Load Balancer as we will not be using it for this scenario."]}),"\n",(0,a.jsx)(t.li,{children:"Set up the firewall rules on the Linux VM"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"The new firewall rules are:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"iptables -A FORWARD -p tcp --syn --dport 80 -m conntrack --ctstate NEW -j ACCEPT\niptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\niptables -P FORWARD DROP\niptables -t nat -A PREROUTING -i eth0 -p tcp --dport 49181 -j DNAT --to-destination 10.224.0.118:80\niptables -t nat -A POSTROUTING -o eth0 -p tcp --dport 80 -d 10.224.0.118 -j SNAT --to-source 10.3.0.4\n"})}),"\n",(0,a.jsx)(t.p,{children:"Explanation:"}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Rule"}),(0,a.jsx)(t.th,{children:"Notes"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"iptables -A PREROUTING -i eth0 -p tcp -m tcp --dport 49181 -j DNAT --to-destination 10.224.0.118:80"}),(0,a.jsx)(t.td,{children:"Packet arrived on eth0 (coming from the public IP of the VM) and get's DNAT'ed to the POD private IP on port 80."})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"iptables -A FORWARD -p tcp -m tcp --dport 80 -m conntrack --ctstate NEW -j ACCEPT"}),(0,a.jsx)(t.td,{children:"At this point, the original packets are now going to be send to port 80. This rule allows that flow."})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT"}),(0,a.jsx)(t.td,{children:"Match any packet that is related to an existing connection, using the conntrack module. This is necessary to allow the established and related connections to the internal service."})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"iptables -P FORWARD DROP"}),(0,a.jsx)(t.td,{children:"Set the policy to drop packets in the FORWARD chain. This means, unless specified (see line above) we will drop traffic."})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"iptables -A POSTROUTING -d 10.224.0.118/32 -o eth0 -p tcp -m tcp --dport 80 -j SNAT --to-source 10.3.0.4"}),(0,a.jsx)(t.td,{children:"The last rule before the packet leaves the kernel, we run a Source NAT (SNAT) and add the Firewall private IP so the pod knows where to return this packet to. Once that packet hits the firewall, we can return it to the sender on the Internet."})]})]})]}),"\n",(0,a.jsx)(t.h4,{id:"testing-and-validating",children:"Testing and validating"}),"\n",(0,a.jsx)(t.p,{children:"To test and verify that the port forwarding rules are working - for both scenarios - you can use a tool like telnet or curl to connect to the external port 49181 from another host. You should see the response from the internal service on port 80. For example, the following command will send a HTTP request to the external port 49181 and display the response:"}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Test case"}),(0,a.jsx)(t.th,{children:"Target"}),(0,a.jsx)(t.th,{children:"Note"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"From the firewall to the pod"}),(0,a.jsx)(t.td,{children:(0,a.jsx)(t.code,{children:"curl http://${POD_IP_ADDRESS}"})}),(0,a.jsx)(t.td,{children:"Pod listens on port 80"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"From the Internet to the public IP of the firewall"}),(0,a.jsx)(t.td,{children:(0,a.jsx)(t.code,{children:"curl http://${PUBLIC_IP}:49181"})}),(0,a.jsx)(t.td,{children:"This connection will be DNATed to proper endpoint (pod or ILB)"})]})]})]}),"\n",(0,a.jsx)(t.p,{children:"You should see something like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'tmp-shell:~# python3 -m http.server 80\nServing HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...\n10.3.0.4 - - [02/Feb/2024 20:50:32] "GET / HTTP/1.1" 200 -\n10.3.0.4 - - [02/Feb/2024 20:50:33] "GET / HTTP/1.1" 200 -\n10.3.0.4 - - [02/Feb/2024 20:50:34] "GET / HTTP/1.1" 200 -\n10.3.0.4 - - [02/Feb/2024 20:50:35] "GET / HTTP/1.1" 200 -\n'})}),"\n",(0,a.jsx)(t.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(t.p,{children:"In this article we've explored how create your own - basic - network virtual appliance and route traffic to an AKS cluster. from here, you can take this as a base for more complex and custom examples. Good luck !"})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},4372:e=>{e.exports=JSON.parse('{"permalink":"/2024/02/02/securing-your-aks-cluster-with-a-linux-firewall-vm","editUrl":"https://github.com/appdevgbb/gbb-blog/tree/main/docusaurus/blog/2024-02-02/securing-your-aks-cluster-with-a-linux-firewall-vm/index.md","source":"@site/blog/2024-02-02/securing-your-aks-cluster-with-a-linux-firewall-vm/index.md","title":"Securing your AKS cluster with a Linux Firewall VM","description":"How to configure the firewall VM, the virtual network, and the network security group to route traffic to your AKS endpoints.","date":"2024-02-02T00:00:00.000Z","tags":[],"readingTime":8.36,"hasTruncateMarker":true,"authors":[{"name":"Diego Casati","title":"Principal Cloud Architect, Azure Global Black Belt","url":"https://github.com/dcasati","socials":{"x":"https://x.com/ve6dpc","github":"https://github.com/dcasati"},"imageURL":"https://github.com/dcasati.png","key":"diego_casati","page":null}],"frontMatter":{"authors":["diego_casati"],"date":"2024-02-02","description":"How to configure the firewall VM, the virtual network, and the network security group to route traffic to your AKS endpoints.","tags":[],"title":"Securing your AKS cluster with a Linux Firewall VM"},"unlisted":false,"prevItem":{"title":"Using the Azure Key Vault CSI Driver with Workload Identity","permalink":"/2024/03/05/workload-identity-kv-csi"},"nextItem":{"title":"Using Workload Idenity to Access Azure Blob Storage","permalink":"/2023/12/19/workload-identity-blob-example"}}')},5178:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/scenario2-1a85bc5a64a9b225b36d9e842d090703.jpg"},7781:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/scenario1-7224d454ad73fad28428d20fd9748538.jpg"},8453:(e,t,n)=>{n.d(t,{R:()=>l,x:()=>o});var r=n(6540);const a={},i=r.createContext(a);function l(e){const t=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);