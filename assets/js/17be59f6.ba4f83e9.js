"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[8910],{3101:e=>{e.exports=JSON.parse('{"permalink":"/2023/11/09/part1-notation-usage","editUrl":"https://github.com/appdevgbb/gbb-blog/tree/main/docusaurus/blog/2023-11-09/part1-notation-usage/index.md","source":"@site/blog/2023-11-09/part1-notation-usage/index.md","title":"Image Verification Part 1 - Notation CLI","description":"How to use the Notary project\'s \'notation\' cli tool to sign and verify container images","date":"2023-11-09T00:00:00.000Z","tags":[],"readingTime":6.25,"hasTruncateMarker":true,"authors":[{"name":"Steve Griffith","title":"Principal Cloud Architect, Azure Global Black Belt","url":"https://github.com/swgriffith","socials":{"x":"https://x.com/SteveGriffith","github":"https://github.com/swgriffith"},"imageURL":"https://github.com/swgriffith.png","key":"steve_griffith","page":null}],"frontMatter":{"authors":["steve_griffith"],"date":"2023-11-09","description":"How to use the Notary project\'s \'notation\' cli tool to sign and verify container images","tags":[],"title":"Image Verification Part 1 - Notation CLI"},"unlisted":false,"prevItem":{"title":"Using Linux Capabilities in AKS","permalink":"/2023/11/27/capabilities-in-aks"},"nextItem":{"title":"Image Verification Part 2 - Image Verification with Gatekeeper and Ratify","permalink":"/2023/11/09/part2-aks-image-verification"}}')},4743:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var i=n(3101),a=n(4848),o=n(8453);const r={authors:["steve_griffith"],date:"2023-11-09",description:"How to use the Notary project's 'notation' cli tool to sign and verify container images",tags:[],title:"Image Verification Part 1 - Notation CLI"},s="Part 1 - Image Signing with Notation",l={authorsImageUrls:[void 0]},c=[{value:"Introduction",id:"introduction",level:2},{value:"Installation",id:"installation",level:2},{value:"Azure Container Registry",id:"azure-container-registry",level:2},{value:"Cleanup",id:"cleanup",level:2},{value:"Sign Images with a Cert from Azure Key Vault",id:"sign-images-with-a-cert-from-azure-key-vault",level:2},{value:"Conclusion",id:"conclusion",level:2}];function u(e){const t={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsxs)(t.p,{children:["This is part one of a two part post on container image signing and runtime verification. In this post, we'll walk through the ",(0,a.jsx)(t.a,{href:"https://github.com/notaryproject/notation",children:"notation"})," project and its ability to sign container images, using the ",(0,a.jsx)(t.a,{href:"https://github.com/notaryproject/specifications",children:"Notary"})," project specification. In the next post, we'll walk through setting up ",(0,a.jsx)(t.a,{href:"https://open-policy-agent.github.io/gatekeeper/website/",children:"gatekeeper"})," and ",(0,a.jsx)(t.a,{href:"https://github.com/deislabs/ratify/blob/main/README.md",children:"ratify"})," to perform policy based runtime verification of images."]}),"\n",(0,a.jsx)(t.h2,{id:"installation",children:"Installation"}),"\n",(0,a.jsx)(t.p,{children:"For this walk through you'll need to have Docker running locally, and have the notation cli installed. You can find the install steps for each in the list below:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://www.docker.com/get-started/",children:"Docker"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://notaryproject.dev/docs/user-guides/installation/cli/",children:"Notation CLI"})}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"azure-container-registry",children:"Azure Container Registry"}),"\n",(0,a.jsx)(t.p,{children:"You can really use any OCI compatible registry, but since we'll later be using AKS for verification, we'll create an Azure Container Registery for use in the following steps."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"# Setup Environment Variables\nRG=EphNotationTesting\nLOC=eastus\nACR_NAME=mynotationlab\n\n# Create the resource group\naz group create -n $RG -l $LOC\n\n# Create the Azure Container Registry\naz acr create -g $RG -n $ACR_NAME --sku Standard\n\n# Login to the ACR\naz acr login -n $ACR_NAME\n"})}),"\n",(0,a.jsx)(t.p,{children:"We could build our own container image from scratch, but the image signing process doesnt really change, so let's just import an existing image to use. This is a good demonstration of the best practice of never directly pulling public images. Instead of direclty pulling public images into your cluster, you should import and verify any public images you wish to use. We'll take it a step further by also signing the imported image."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"# For later testing, lets also import an unsigned image\naz acr import --name $ACR_NAME --source docker.io/library/nginx:1.25.3 --image nginx:1.25.3\n"})}),"\n",(0,a.jsx)(t.p,{children:"Now we can play around with notation. Notation does require you use the image SHA instead of tags, so we'll get that first."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'# Get the nginx image SHA\nIMAGE_SHA=$(az acr repository show -n $ACR_NAME --image "nginx:1.25.3" -o tsv --query digest)\n'})}),"\n",(0,a.jsx)(t.p,{children:"Now we'll use the notation cli to check the image for existing signatures and then create and apply a new signature. The notation project does provide the ability to generate a test certificate locally to get you up and running quickly. We'll try that first and then move on to using Azure Key Vault for the certificate."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'# List the signatures on the image\n# You should see the image has no signatures\nnotation ls $ACR_NAME.azurecr.io/nginx@$IMAGE_SHA\n\n# Generate a test RSA key and self-signed certificat\nnotation cert generate-test --default "brooklyn.io"\n\n# List certs to confirm the cert exists\nnotation cert ls\n\n# Sign the image\nnotation sign $ACR_NAME.azurecr.io/nginx@$IMAGE_SHA\n\n# Now check the image signatures\n# You should now see that the image is signed\nnotation ls $ACR_NAME.azurecr.io/nginx@$IMAGE_SHA\n'})}),"\n",(0,a.jsx)(t.p,{children:"You should now have a successfully signed image. Next, we can use notation to verify the image has been signed. For that we'll need to create a local trust policy for notation."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'# Create a trust policy for notation\ncat <<EOF > ./trustpolicy.json\n{\n    "version": "1.0",\n    "trustPolicies": [\n        {\n            "name": "brooklyn-images",\n            "registryScopes": [ "*" ],\n            "signatureVerification": {\n                "level" : "strict"\n            },\n            "trustStores": [ "ca:brooklyn.io" ],\n            "trustedIdentities": [\n                "*"\n            ]\n        }\n    ]\n}\nEOF\n\n# Import the policy\nnotation policy import ./trustpolicy.json\n\n# Show the policy\nnotation policy show\n\n# Verify the image meets the policy\n# You should get a message that the signature was verified\nnotation verify $ACR_NAME.azurecr.io/nginx@$IMAGE_SHA\n'})}),"\n",(0,a.jsx)(t.h2,{id:"cleanup",children:"Cleanup"}),"\n",(0,a.jsxs)(t.p,{children:["Before moving on, we should delete and re-import the image, since we dont want the local test certificate on the image any more. You can also remove the signature with ",(0,a.jsx)(t.a,{href:"https://notaryproject.dev/docs/user-guides/how-to/manage-signatures/#delete-a-signature-on-an-artifact",children:"oras"}),", but we'll keep it simple for now."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'# Delete and re-import the image\naz acr repository delete -n $ACR_NAME --repository nginx -y\naz acr import --name $ACR_NAME --source docker.io/library/nginx:1.25.3 --image nginx:1.25.3\nIMAGE_SHA=$(az acr repository show -n $ACR_NAME --image "nginx:1.25.3" -o tsv --query digest)\n'})}),"\n",(0,a.jsx)(t.h2,{id:"sign-images-with-a-cert-from-azure-key-vault",children:"Sign Images with a Cert from Azure Key Vault"}),"\n",(0,a.jsx)(t.p,{children:"Using the notation locally generated test certificate does give you some level of comfort about the source of the image, but you really want to use a certificate from a trusted store. It's also important to have an accessible store that can be used by remote processes, like your devops pipeline. Fortunately, notation provides a plugin for Azure Key Vault which can be used to sign images with certifiates source from Azure Key Vault."}),"\n",(0,a.jsxs)(t.p,{children:["First you need to install the Azure Key Vault plug-in for notation. You can find instructions for your OS ",(0,a.jsx)(t.a,{href:"https://github.com/Azure/notation-azure-kv#installation-the-akv-plugin",children:"here"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"# Confirm you successfuly installed the plugin\nnotation plugin list\n\n# Sample Output\nNAME       DESCRIPTION                       VERSION   CAPABILITIES                ERROR\nazure-kv   Notation Azure Key Vault plugin   1.0.1     [SIGNATURE_GENERATOR.RAW]   <nil>\n"})}),"\n",(0,a.jsx)(t.p,{children:"Now we'll create an Azure Key Vault instance for our test and configure the signature. It's important that the secret properties specify that the content type  is 'application/x-pem-file' as ratify, which we'll use later, cannot read the default PFX format."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'AKV_NAME=mynotationtest\n\n# Create the key vault\naz keyvault create --name $AKV_NAME --resource-group $RG --enable-rbac-authorization false\n\n# Set some variables for the cert creation\n# Name of the certificate created in AKV\nCERT_NAME=brooklyn-io\nCERT_SUBJECT="CN=brooklyn.io,O=Notation,L=Brooklyn,ST=NY,C=US"\nCERT_PATH=./${CERT_NAME}.pem\n\n# Set the access policy for yourself to create and get certs\nUSER_ID=$(az ad signed-in-user show --query id -o tsv)\naz keyvault set-policy -n $AKV_NAME --certificate-permissions create get --key-permissions sign --object-id $USER_ID\n\n# Create the Key Vault certificate policy file\ncat <<EOF > ./brooklyn_io_policy.json\n{\n    "issuerParameters": {\n    "certificateTransparency": null,\n    "name": "Self"\n    },\n    "keyProperties": {\n      "exportable": false,\n      "keySize": 2048,\n      "keyType": "RSA",\n      "reuseKey": true\n    },\n    "secretProperties": {\n        "contentType": "application/x-pem-file"\n    },\n    "x509CertificateProperties": {\n    "ekus": [\n        "1.3.6.1.5.5.7.3.3"\n    ],\n    "keyUsage": [\n        "digitalSignature"\n    ],\n    "subject": "${CERT_SUBJECT}",\n    "validityInMonths": 12\n    }\n}\nEOF\n\n# Create the signing certificate\naz keyvault certificate create -n $CERT_NAME --vault-name $AKV_NAME -p @brooklyn_io_policy.json\n\n# Get the Key ID of the signing key\nKEY_ID=$(az keyvault certificate show -n $CERT_NAME --vault-name $AKV_NAME --query \'kid\' -o tsv)\n\n# Now sign the previosly imported nginx image\n# You should get a confirmation that the image was successfully signed\nnotation sign --signature-format cose --id $KEY_ID --plugin azure-kv --plugin-config self_signed=true $ACR_NAME.azurecr.io/nginx@$IMAGE_SHA\n\n# Confirm the signature\nnotation ls $ACR_NAME.azurecr.io/nginx@$IMAGE_SHA\n'})}),"\n",(0,a.jsx)(t.p,{children:"Finally, now that we have the image signed with our certifcate from Azure Key Vault, lets set up our local environment trust policy to allow us to verify the image signature is valid locally. We'll need to download the certificate and add a local trust store."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'# Download the cert from Azure Key Vault so we can verify the image locally with the AKV cert\naz keyvault certificate download --name $CERT_NAME --vault-name $AKV_NAME --file $CERT_PATH\n\nSTORE_TYPE="ca"\nSTORE_NAME="brooklyn.io"\nnotation cert add --type $STORE_TYPE --store $STORE_NAME $CERT_PATH\n\ncat <<EOF > ./trustpolicy.json\n{\n    "version": "1.0",\n    "trustPolicies": [\n        {\n            "name": "brooklyn-images",\n            "registryScopes": [ "$ACR_NAME.azurecr.io/nginx" ],\n            "signatureVerification": {\n                "level" : "strict" \n            },\n            "trustStores": [ "$STORE_TYPE:$STORE_NAME" ],\n            "trustedIdentities": [\n                "x509.subject: $CERT_SUBJECT"\n            ]\n        }\n    ]\n}\nEOF\n\n# Import the policy and show it\nnotation policy import ./trustpolicy.json\nnotation policy show\n\n# Test image verification\nnotation verify $ACR_NAME.azurecr.io/nginx@$IMAGE_SHA\n\n# Sample success message!!!\nSuccessfully verified signature for mynotationlab.azurecr.io/nginx@sha256:86e53c4c16a6a276b204b0fd3a8143d86547c967dc8258b3d47c3a21bb68d3c6\n'})}),"\n",(0,a.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(t.p,{children:"You should now have some familiarity with the notation cli tool and how to use it to sign container images in a container registry with both self-signed certificates and certificates from Azure Key Vault. The next step would be to enable verification in kubernetes."}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Next:"})," ",(0,a.jsx)(t.a,{href:"./part2-aks-image-verification.html",children:"Part 2 - Image Verification in AKS"})]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>s});var i=n(6540);const a={},o=i.createContext(a);function r(e){const t=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);